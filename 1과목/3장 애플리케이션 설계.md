# 애플리케이션 설계

## 목차

- [소프트웨어 아키텍처](#first)
- [아키텍처 패턴](#second)
- [객체지향(Object-Oriented)](#third)
- [모듈](#fourth)
- [공통 모듈](#fifth)
- [코드](#sixth)
- [디자인 패턴](#seventh)

---

1. 소프트웨어 아키텍처<a id="first"></a>

   - 소프트웨어 아키텍처의 설계

     아키텍처: 원칙과 지침의 역할을 할 수 있는 것<br/>소프트웨어 아키텍처는 소프트웨어의 골격이 되는 기본구조 입니다.<br/>기본적으로 좋은 품질을 유지하면서 사용자의 비기능적 요구사항으로 나타난 제약을 반영합니다.

   - 모듈화

     모듈의 크기를 너무 작게 나누면 개수가 많아져 모듈 간의 통합 비용이 많이 들고, 너무 크게 나누면 개수가 적어 통합 비용은 적게 들지만 모듈 하나의 개발 비용이 많이 듭니다. ->  조율이 필요합니다.

   - 추상화

     포괄하기 위해서가 아니고 구체화 하기 위해서 입니다.<br/>

     - 추상화의 유형

       | 과정 추상화   | 자세한 수행 과정을 정의하지 않고, 전반적인 흐름만 파악할 수 있게 설계하는 방법 |
       | ------------- | ------------------------------------------------------------ |
       | 데이터 추상화 | 데이터의 세부적인 속성이나 용도를 정의하지 않고, 데이터 구조를 대표할 수 있는 표현으로 대체하는 방법입니다. |
       | 제어 추상화   | 이벤트 발생의 정확한 절차나 방법을 정의하지 않고, 대표할 수 있는 표현으로 대체하는 방법입니다. |

   - 단계적 분해

     세부적 분해 중 추상화를 할수록 좀 더 구체적인 분해가 가능합니다. -> 하향식 구체화<br/>추상화의 반복에 의해서 세분화됩니다.<br/>소프트웨어의 기능에서부터 시작하여 점차적으로 구체화하고, 알고리즘, 자료구조 등 상세한 내역은 가능한 한 뒤로 미루어 진행합니다.

   - 정보은닉

     각각 모듈이 서로 접근할 수 없도록 차단하는 과정입니다. 대신 별도의 인터페이스로만 접근이 허락됩니다.<br/>다른 모듈에 영향을 주지 않으므로 수정, 시험, 유지보수가 용이합니다.

   - 소프트웨어 아키텍처의 품질 속성

     시스템 측면, 비즈니스 측면, 아키텍처 측면이 있습니다.

   - 소프트웨어 아키텍처의 설계 과정

     - 설계 목표 설정

       개발 방향을 명확히 하기 위해 설계에 영향을 주는 목표를 설정

     - 시스템 타입 결정

       시스템과 서브시스템의 타입을 결정하고, 설계 목표와 함께 고려하여 아키텍처 패턴을 선택합니다.

     - 아키텍처 패턴 적용

       미리 만들어 놓은 공식

     - 서브시스템 구체화

       인터페이스 인터렉션

     - 검토

       설계의 기본 원리를 만족하는지 등을 검토합니다.

     <br/>

     시스템 타입

     - 대화형 시스템: 사용자의 요구가 발생하면 시스템이 이를 처리하고 반응하는 시스템
     - 이벤트 중심 시스템: 외부의 상태 변화에 따라 동작하는 시스템
     - 변환형 시스템: 데이터가 입력되면 정해진 작업들을 수행하여 결과를 출력하는 시스템
     - 객체 영속형 시스템: 데이터베이스를 사용하여 파일을 효과적으로 저장, 검색, 갱신할 수 있는 시스템

   <br/>

   ---

2. 아키텍처 패턴<a id="second"></a>

   - 아키텍처 패턴

     문제 해결의 윤곽제시, 원칙과 지침 역할, 아키텍처 스타일, 표중 아키텍처도 같은 말

     - 아키텍처 패턴의 장점(긍정적)

       시간을 단축시키고 품질 향상, 검증 편리, 소통 원활, 이해 용이, 예측가능 등이 있습니다.

   - 레이어 패턴

     상위, 하위 레이어끼리만 상호작용합니다.<br/>특정 계층만을 교체해 시스템을 개선하는 것이 가능합니다.

   - 클라이언트-서버 패턴

     클라이언트를 통해 서버에 요청하고 클라이언트가 응답을 받아 사용자에게 제공하는 방식<br/>서버는 클라이언트의 요청에 대비해 항상 대기 상태를 유지해야 합니다.<br/>클라이언트나 서버는 독립적입니다.

   - 파이프-필터 패턴

     스트림을 파이프와 필터로 연결하는 것 입니다. (필터: 처리하고 캡슐화 하는 것)<br/>필터 컴포넌트는 재사용성이 좋고, 추가가 쉬워 확장이 용이합니다.<br/>다양한 파이프라인을 구축하는 것이 가능합니다.<br/>데이터 변환, 버퍼링, 동기화 등에 주로 사용됩니다.

   - 모델-뷰-컨트롤러 패턴

     - 모델(Model): 서브시스템의 핵심 기능과 데이터를 보관합니다.
     - 뷰(View): 사용자에게 정보를 표시합니다.
     - 컨트롤러(Controller): 사용자로부터 받은 입력을 처리합니다.

   - 마스터-슬레이브 패턴

     마스터 컴포넌트가 지시한 일을 여러 슬레이브가 병렬처리하여 결과를 취합합니다.

   - 브로커 패턴

     사용자가 원하는 서비스와 특성을 브로커 컴포넌트에 요청하면 브로커 컴포넌트가 요청에 맞는 컴포넌트와 사용자를 연결해줍니다.<br/>분산 환경 시스템에서 주로 활용됩니다.

   - 피어-투-피어 패턴

     서버와 클라이언트가 서로 역할을 바꿀 수 있습니다.<br/>서버는 전형적인 멀티스레딩 방식을 사용합니다.

   - 이벤트-버스 패턴

     이벤트 메시지를 발행하면, 해당 채널을 구독한 리스너들이 메시지를 받아 이벤트를 처리하는 방식입니다.

   - 블랙보드 패턴

     컴포넌트들은 검색을 통해 블랙보드에서 원하는 데이터를 찾을 수 있습니다.<br/>음성 인식, 차량 식별, 신호 해석 등에 주로 활용됩니다.

   - 인터프리터 패턴

     코드의 각 라인을 수행하는 방법을 지정하고, 기호마다 클래스를 갖도록 구성됩니다.

   <br/>

   ---

3. 객체지향(Object-Oriented)<a id="third"></a>

   - 객체, 클래스, 캡슐화, 상속, 다형성

   
<br/>
   
---
   
4. 모듈<a id="fourth"></a>

   - 모듈

     각 모듈의 기능이 서로 독립됨을 의미하는 것<br/>독립성이 높은 모듈일수록 모듈을 수정하더라도 다른 모듈들에게는 거의 영향을 미치지 않으며, 오류가 발생해도 쉽게 발견하고 해결할 수 있습니다.<br/>모듈의 독립성은 결합도와 응집도에 의해 측정됩니다.

   - 결합도

     모듈 간의 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계를 의미합니다.<br/>결합도가 약할수록 품질이 높고, 강할수록 품질이 낮습니다.

     | 자료 결합도      | 모듈간의 인터페이스가 데이터로만 구성될 때의 결합도입니다.   |
     | ---------------- | ------------------------------------------------------------ |
     | 스탬프 결합도    | 다른 모듈이 영향을 받게 됩니다.<br/>자료구조가 전달될 때의 결합도입니다. |
     | 제어 결합도      | 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 신호를 이용하여 통신하거나 제어 요소를 전달하는 결합도입니다. |
     | 외부 결합도      | 외부의 다른 모듈에서 참조할 때의 결합도입니다.               |
     | 공통(공유)결합도 | 공유되는 공통 데이터의 영역을 여러 모듈이 사용할 때의 결합도입니다. |
     | 내용 결합도      | 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도입니다. |

   - 응집도

     정보 은닉 개념을 확장한 것<br/>독립적인 기능으로 정의<br/>응집도가 강할수록 품질이 높고, 약할수록 품질이 낮습니다.

     | 기능적 응집도       | 단일 문제에 단일 기능만 연관                                 |
     | ------------------- | ------------------------------------------------------------ |
     | 순차적 응집도(전후) | 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도 |
     | 교환(통신)적 응집도 | 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우의 응집도(둘 이상 모듈이 관련) |
     | 절차적 응집도(다수) | 다수의 관련 기능을 순차적으로 수행할 경우의 응집도           |
     | 시간적 응집도       | 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도 |
     | 논리적 응집도       | 유사한 성격을 갖는 모듈이 형성되는 경우의 응집도             |
     | 우연적 응집도       | 서로 관련 없는 요소로만 구성된 경우의 응집도                 |

   - 팬인(Fan-In) / 팬아웃(Fan-out)

     제어신호가 들어온다 / 나간다

     | 기법   | 설명                               |
     | ------ | ---------------------------------- |
     | 정확성 | 필요선                             |
     | 명확성 | 비중의적(한가지 의미로 해석되도록) |
     | 완전성 | 필요한 모든것                      |
     | 일관성 | 충돌방지                           |
     | 추적성 | 출처, 관계파악                     |

   <br/>

   ---

5. 공통 모듈<a id="fifth"></a>

   - 효과적인 모듈 설계 방안

     결합도는 줄이고 응집도는 높여서 모듈의 독립성과 재사용성을 높입니다.<br/>복잡도와 중복성을 줄이고 일관성을 유지시킵니다.

   <br/>

   ---

6. 코드<a id="sixth"></a>

   - 코드의 종류

     일정한 규칙에 의해 만들어진 것

     | 순차 코드                  | 자료의 발생순서, 크기순서 등의 기준에 따라 차례대로 일련번호를 부여하는 방법 |
  | -------------------------- | ------------------------------------------------------------ |
     | 블록 코드                  | 블록으로 구분하고, 각 블록 내에서 일련 번호를 부여하는 방법  |
  | 10진 코드(1자리)           | 10진 분할하는 방법을 필요한 만큼 반복하는 방법               |
     | 그룹 분류 코드(2자리 이상) | 각 그룹 안에서 일련 번호를 부여하는 방법                     |
  | 연상 코드                  | 코드화 대상 항목의 명칭이나 약호와 관계이쓴ㄴ 숫자나 문자, 기호를 이용하여 코드를 부여하는 방법 |
     | 표의 숫자 코드             | 물리적 수치를 그대로 코드에 적용시키는 방법, 유효숫자코드라고도 불립니다. |

   <br/>

   ---
   
7. 디자인 패턴<a id="seventh"></a>

   - 생성 패턴

     객체의 생성과 관련된 패턴으로 총 5개의 패턴이 있습니다.

     | 추상 팩토리   | 상위 클래스의 객체 생성코드를 하위 클래스가 상속             |
     | ------------- | ------------------------------------------------------------ |
     | 빌더          | 작게 분리된 인스턴스를 건축 하듯이 조합하여 객체를 생성      |
     | 팩토리 메소드 | 객체 생성 코드를 하위 클래스에서 구체화<br/>상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당 |
     | 프로토타입    | 원본 객체를 복원하는 방법으로 객체를 생성하는 패턴           |
     | 싱글톤        | 생성된 인스턴스는 동시에 참조할 수 없습니다.<br/>클래스 내에서 인스턴스가 하나뿐임을 보장합니다. |

   - 구조 패턴

     구조 패턴은 구조가 복잡한 시스템을 개발하기 쉽게 도와줍니다.

     | 어댑터       | 기존의 클래스를 이용하고 싶지만 인터페이스가 일치하지 않을 때 이용 |
     | ------------ | ------------------------------------------------------------ |
     | 브리지       | 기능과 구현을 두 개의 별도 클래스로 구현합니다.<br/>서로가 독립적으로 확장할 수 있도록 구성한 패턴 |
     | 컴포지트     | 트리 구조로 구성, 단일객체와 복합객체 구분없이 다룸          |
     | 데코레이터   | 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식 |
     | 퍼싸드       | 서브 클래스들 사이의 통합 인터페이스를 제공하는 Wrapper 객체가 필요<br/>서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴 |
     | 플레이웨이트 | 다수의 유사 객체를 생성하거나 조작할 때 유용하게 사용<br/>서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴 |
     | 프록시       | 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴 |

   - 행위 패턴

     상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴<br/>하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하면서 결합도를 최소화 할 수 있도록 도와줍니다.

     | 책임 연쇄     | 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴<br/>각 객체들이 고리로 묶여 있어 요청이 해결될 때까지 고리를 따라 책임이 넘어갑니다. |
     | ------------- | ------------------------------------------------------------ |
     | 커맨드        | 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴 |
     | 인터프리터    | 언어에 문법 표현을 정의하는 패턴                             |
     | 반복자        | 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴<br/>객체 사이의 의존성을 줄여 결합도를 감소 |
     | 중재자        | 수많은 객체들 간의 복자한 상호작용을 캡슐화하여 객체로 정의하는 패턴<br/>객체 사이의 의존성을 줄여 결합도를 감소 |
     | 메멘토        | 특정 씨점에서의 객체 내부 상태를 객체화<br/>해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴 |
     | 옵서버        | 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴 |
     | 상태          | 객체 상태를 캡슐화하고 이를 참조하는 방식으로 처리           |
     | 전략          | 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환<br/>독립적으로 원하는 알고리즘을 선택하여 사용할 수 있으며, 클라이언트에 영향 없이 알고리즘의 변경이 가능 |
     | 템플릿 메소드 | 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화<br/>코드의 양을 줄이고 유지보수를 용이하게 해 줍니다. |
     | 방문자        | 처리기능은 각 클래스를 방문<br/>데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴 |

     


   

   